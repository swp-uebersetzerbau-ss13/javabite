<!DOCTYPE html>
<!-- saved from url=(0054)http://documentup.com/swp-uebersetzerbau-ss13/javabite -->
<html class="wf-adelle-n4-active wf-adelle-i4-active wf-adelle-n7-active wf-adelle-i7-active wf-active"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javabite</title>
    
    <link rel="stylesheet" type="text/css" href="./README_files/screen.css">
    
    

    

    <!-- Typekit -->
    
      <script src="./README_files/hjp0pft.js" type="text/javascript" async=""></script><script type="text/javascript">
        (function() {
          var config = {
            kitId: 'hjp0pft',
            scriptTimeout: 3000
          };
          var h=document.getElementsByTagName("html")[0];h.className+=" wf-loading";var t=setTimeout(function(){h.className=h.className.replace(/( |^)wf-loading( |$)/g,"");h.className+=" wf-inactive"},config.scriptTimeout);var tk=document.createElement("script");tk.src='//use.typekit.net/'+config.kitId+'.js';tk.type="text/javascript";tk.async="true";tk.onload=tk.onreadystatechange=function(){var a=this.readyState;if(a&&a!="complete"&&a!="loaded")return;clearTimeout(t);try{Typekit.load(config)}catch(b){}};var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(tk,s)
        })();
      </script><style type="text/css">.tk-adelle{font-family:"adelle",serif;}</style><link rel="stylesheet" href="http://use.typekit.net/k/hjp0pft-d.css?3bb2a6e53c9684ffdc9a9bf01b5b2a62ec6379d745fd2575909b9300b5707f02cb2ddcd5078d03b6d9259656df038f6d1266b16f69aee39a5c1d1b81f2a47392b7e6399dd3a04e8fd8b8902a4ba5c08f5c01b3f138717cb3ed683592649533826ccadaaac8dd808a2c94c961c124dab69e5a895ba7ecb919a1ad3ecab6677c0c0e193f375acdeff5e7f08a7896ff9359c781a4ff7b6fbc43d3799e6e4ca506ca23">
    
  <style type="text/css"></style></head>
  <body><div id="container">
  <div id="nav">
    
      <div id="header">
        <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#" id="logo">javabite</a>
      </div>
    
    <ul id="sections">
      
        <li>
          <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#what-can-you-find-in-this-repository">What can you find in this repository?</a>
          
        </li>
      
        <li>
          <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#quickstart">Quickstart</a>
          
        </li>
      
        <li>
          <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions">Module Descriptions</a>
          
            <ul>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/lexer">Lexer</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/parser">Parser</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/semantical-analyser">Semantical Analyser</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/intermediate-code-generator">Intermediate Code Generator</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/backend">Backend</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/compiler">Compiler</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#module-descriptions/ide-environment">IDE Environment</a>
                </li>
              
            </ul>
          
        </li>
      
        <li>
          <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#project-structure">Project Structure</a>
          
            <ul>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#project-structure/setup-of-development-environment">Setup of development environment</a>
                </li>
              
                <li>
                  <a href="http://documentup.com/swp-uebersetzerbau-ss13/javabite#project-structure/runtime-test">Runtime test</a>
                </li>
              
            </ul>
          
        </li>
      
    </ul>
    
      <div class="extra" id="github">
        <a href="https://github.com/swp-uebersetzerbau-ss13/javabite">Source on Github</a>
      </div>
      
        <div class="extra" id="github-issues">
          <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/issues">Issues</a>
        </div>
      
      
    
    
  </div>
  <div id="content">
    
      <a href="https://github.com/swp-uebersetzerbau-ss13/javabite" id="github-ribbon"><img src="./README_files/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
    
    <h1>javabite</h1>
<p>Javabite is a compiler for a language, mostly named <strong>'PROG'</strong>, described by the related repository 
</p>
<p><a href="https://github.com/swp-uebersetzerbau-ss13/common">https://github.com/swp-uebersetzerbau-ss13/common</a>.

</p>
<h2 id="what-can-you-find-in-this-repository">What can you find in this repository?</h2>
<p>This repository contains implementations for all interfaces defined by the common-repository mentioned above, a CLI compiler utilizing the implemented compiler modules and a minimalitic IDE-like GUI with visualization of datastructures of the compilation process like the Abstract Syntax Tree (AST) and the Three Address Code (TAC). 

</p>
<p>The compiler is developed in <strong>JAVA</strong> and generates <strong>target code</strong> for the <strong>JVM 1.7</strong>. The compiler is modulazied into five parts:

</p>
<ol>
<li>Lexer<ul>
<li>The lexer tokenize the input into word of the <a href="https://github.com/swp-uebersetzerbau-ss13/common/wiki/Grammar">grammar of <strong>PROG</strong></a></li>
</ul>
</li>
<li>Parser<ul>
<li>The parser converts the token stream provided by the lexer into an AST.</li>
</ul>
</li>
<li>Semantical Analyzer<ul>
<li>The semantical analyzer checks if the generated AST is wellformed considering the <a href="https://github.com/swp-uebersetzerbau-ss13/common/wiki/Grammar#semantic">semantic defined for the grammer</a></li>
</ul>
</li>
<li>Intermediate Code Generator<ul>
<li>The intermediate code generator takes this check AST and converts it into the <a href="https://github.com/swp-uebersetzerbau-ss13/common/wiki/Grammar#semantic">intermediate TAC</a></li>
</ul>
</li>
<li>Backend<ul>
<li>The backend converts the TAC into the target code which is <strong>Java ByteCode</strong> for <em>Javabite</em> </li>
</ul>
</li>
</ol>
<p>All modules are also implemented against the same interfaces by the second team working in <a href="https://github.com/swp-uebersetzerbau-ss13/fuc">https://github.com/swp-uebersetzerbau-ss13/fuc</a>. They provide alternative implementations of the frontend modules (all but Backend) and a backend module targeting the <a href="http://llvm.org/">LLVM</a>

</p>
<h2 id="quickstart">Quickstart</h2>
<p>If you want to try the compiler, execute this command on the shell: 

</p>
<pre><code><span class="title">git</span> clone https://github.com/swp-uebersetzerbau-ss13/javabite.git
<span class="title">cd</span> javabite
<span class="title">git</span> submodule init
<span class="title">git</span> submodule update
<span class="title">gradlew</span> buildCompiler
<span class="title">java</span> -jar bin\javabite-compiler-<span class="number">0.2</span>.jar</code></pre>
<p>This starts the GUI. Examples of <strong>PROG</strong> programs can be found in this repository and in common. Look for files with suffix '.prog'.

</p>
<h2 id="module-descriptions">Module Descriptions</h2>
<p>This section describes the functionality, implementation and structure of the different modules.

</p>
<h3 id="module-descriptions/lexer">Lexer</h3>
<p>The task of the lexer module is to tokenize the incoming sourcecode. This tokenization breaks down the words of the sourcecode into a set of tokens, which are strings. Additionally the lexer adds a context to each token, for example, whether the token is of the type NUM or REAL. With such tokens other compiler modules like the parser can create an AST more easily. The lexer is build with a pattern matcher, that works with the <em>regular expression engine</em> of <em>Java</em> to tokenize the sourcecode. This implementation can be easily updated, because of the fact that only the regular expressions for each token have to be updated. We also can add new tokens by just adding a new token type and a regular expression for it. The list of tokens in the <strong>PROG</strong> grammar can be found in the <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-lexer/src/main/java/swp_compiler_ss13/javabite/lexer/JavabiteTokenType.java">TokenType definition</a> and the used regular expressions are available in the <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-lexer/src/main/java/swp_compiler_ss13/javabite/lexer/JavabiteTokenType.java">JavabiteTokenType definition</a>

</p>
<p>Then lexer implementation is named <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-lexer/src/main/java/swp_compiler_ss13/javabite/lexer/LexerJb.java"><strong>swp_compiler_ss13.javabite.lexer.LexerJb</strong></a>.

</p>
<h3 id="module-descriptions/parser">Parser</h3>
<p>The parser logic has been implemented based on the fundamental knowledge gained from the course <em>Compiler Design</em>. Regardless, it was necessary to tailor some of the learned techniques to our needs. This documentation gives in particular a introduction into the deflexion of the <em>default approach</em>. 
First, we name the important classes and their basic functionality. Thereafter, we show where we had to change the prototype-implementation presented in various lectures. At last, we'll outline how the interaction  between the modules happens and how a typical application of the parser works. 
Long story short, we've successfully implemented a SLR parser

</p>
<h4>Modules and Classes</h4>
<p>There exist several important packages and classes, each of them providing a special kind of functionality.
<em> <strong>swp_compiler_ss13.javabite.parser.grammar.Grammar<t,nt></t,nt></strong> is the most important class of the parser. This class represents a grammar with <strong>T</strong> as terminals and <strong>NT</strong> as NonTerminals, respectively. The implementation provides functions like closure-computation, first- and follow-set determination.  
</em> <strong>swp_compiler_ss13.javabite.parser.targetgrammar.TargetGrammar</strong> is a special subclass of <strong>Grammar</strong>. This class represents the exact programmatic translation of the <a href="https://github.com/swp-uebersetzerbau-ss13/common/wiki/Grammar">grammar of interest</a>. 
<em> <strong>swp_compiler_ss13.javabite.parser.grammar.SLRAutomaton</strong> is a automaton, which can derive the concrete derivation of a given word with a look ahead of 1.
</em> <strong>swp_compiler_ss13.javabite.parser.astGenerator.ASTGenerator</strong> has been developed to translate a derivation ( bottom-up-left-to-right). The result is a Abstract Syntax tree

</p>
<h4>Mentionable Modifications</h4>
<p>Some approaches have to be fitted or completely replaced to use it in our implementation with the given grammar. We note some of them:
<em> It's not traceable to construct the ast when the translation is given in a right-most fashion. We had to translate the right-most derivation in the left-most derivation first in the <strong>TargetGrammar</strong> class.
</em> The SLRAutomaton had to be modified in a way, that the automaton is able to deal with epsilon productions. Another way is to remove the epsilon-productions from the grammar, what results in another grammar. We did want to keep the grammar. In the most common literature, the automaton has not to deal with epsilon productions since they are removed before. Thus, the automaton had to be adjusted.
* The closure, first- and follow set computation can be very complex for large grammars. We decide to differ from a pure functional implementation and implemented cached and/ or pre-computed values as often as possible. This decreases the readability but increases the performance dramatically.

</p>
<h4>Application of the Modules</h4>
<p>A typical application can be drafted as follows:

</p>
<ol>
<li>A word of the grammar is given in form of a sequence of tokens</li>
<li>We abstract from the concrete token and just consider the type ( e.g. "myInt" and "myDouble" as a ID is treated the same way). </li>
<li>We use the abstract token stream to get a concrete derivation of the word with the help of TargetGrammar.</li>
<li>Luckily, we piggy-bagged the information in the abstract token. Now, we have the derivation with the concrete tokens ( e.g. the tokens "myInt" and "myDouble" is again distinguishable).</li>
<li>We use the TargetGrammar to <em>rotate</em> the derivation to gain a left-to-right fashioned derivation.</li>
<li>We use a semantic translation to construct the ast from the derivation in <em>ASTGenerator</em>.</li>
</ol>
<h3 id="module-descriptions/semantical-analyser">Semantical Analyser</h3>
<p>Like the implementation of the parser, we tried to follow as often as possible the prototype approach of the compiler design course. Unfortunately, this not as frequently as in the parser possible. In the next sections, we describe the important modules and after that, a short outline of the use of the semantic analyzer.

</p>
<h4>Modules and Classes</h4>
<p>There are just a few important classes, whose are quickly described:
<em> <strong>swp_compiler_ss13.javabite.semantic.SemanticAnalyzerJb</strong> simply checks for simple division by zero and uses the ASTTypeChecker ( described below) to guarantee type-correctness.
</em> <strong>swp_compiler_ss13.javabite.semantic.ASTTypeChecker</strong> is a very simple S-Attributed check. Implemented by traversing and caching. 


</p>
<h4>Mentionable Modifications</h4>
<p>The best-practice approach would be to create a L-Attributed grammar to check e.g. for invalid break-statement positions. We decided to try it with a less complex approach, since the only semantic errors which cannot be checked by a S-Attributed grammar is the positioning of return and break statements. The implementation is currently under heavy development. We want to take a look at the control flow where it is possible. For example, if a statement exists (unconditional) after a return statement, it's placement is invalid. We try to check this invariant for the whole tree.

</p>
<h4>Application of the Modules</h4>
<p>A typical application can be drafted as follows:

</p>
<ol>
<li>Create a SemanticAnalyzer</li>
<li>analyze the ast of interest with it</li>
<li>interpret the results and errors thrown by the reportErrorLog.</li>
</ol>
<h3 id="module-descriptions/intermediate-code-generator">Intermediate Code Generator</h3>
<p>The intermediate code generator converts the provided AST into a list of quadruple which is the TAC. The implementation for the javabite team <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-code-gen/src/main/java/swp_compiler_ss13/javabite/codegen/IntermediateCodeGeneratorJb.java"><strong>swp_compiler_ss13.javabite.codegen.IntermediateCodeGeneratorJb</strong></a> delegates the conversion of the AST nodes to specialized converters for each node type. The converters calls the generator for processing subnodes, generates necessary quadruples and add them to the quadruple list.

</p>
<p>For the conversion process the converters can access helper methods provided by the generator. The helper methods provided unique temporary variable names and unique names for jump labels. Furthermore there are mechanismns for scope management and mapping from AST to TAC name space.

</p>
<h3 id="module-descriptions/backend">Backend</h3>
<p>The backend generates the <em>Java Bytecode</em> from the TAC. The main class is <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-backend/src/main/java/swp_compiler_ss13/javabite/backend/BackendJb.java"><strong>swp_compiler_ss13.javabite.backend.BackendModule</strong></a>

</p>
<p>Basically the javabite-backend consists of three main components ï¿½ 

</p>
<ol>
<li>a three-address-code optimizer <ul>
<li><a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-backend/src/main/java/swp_compiler_ss13/javabite/backend/translation/TACOptimizer.java">swp_compiler_ss13.javabite.backend.translation.TACOptimizer</a></li>
</ul>
</li>
<li>the actual translator being responsible for translating the three-address-code into java bytecode files <ul>
<li><a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-backend/src/main/java/swp_compiler_ss13/javabite/backend/translation/TargetCodeOptimizer.java">swp_compiler_ss13.javabite.backend.translation.Translator</a></li>
</ul>
</li>
<li>and a target code optimizer, which is supposed to optimize the generated bytecode.<ul>
<li><a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-backend/src/main/java/swp_compiler_ss13/javabite/backend/translation/TargetCodeOptimizer.java">swp_compiler_ss13.javabite.backend.translation.TargetCodeOptimizer</a></li>
</ul>
</li>
</ol>
<p>The optimization components are not implemented, yet, as they are optional.

</p>
<h4>Translator</h4>
<p>The translator translates the three-address-code into java bytecode in several steps:

</p>
<p>swp_compiler_ss13.javabite.backend.translation.Translator.translate(String, List<quadruple>)

</quadruple></p>
<ol>
<li>First, it generates a new classfile object (swp_compiler_ss13.javabite.backend.classfile.Classfile), initializes it with all necessary information considering the jvm specification for classfiles and adds a new 'main'-method object to it, which will be used to run the generated code.</li>
<li>Then, the translator iterates three times over the three-address-code extracting different information.</li>
<li>During the first iteration it looks for variable declarations and allocates appropriate space for every found one in the code attribute of the previously generated classfile's main-method.</li>
<li>During the second iteration the translator looks for all constants in the three-address-code being prefixed with the symbol '#' and adds appropriate constant pool info structures meeting the jvm specification for those ones to the previously generated classfile's constant pool.</li>
<li>During the third iteration, the actual translation takes place and the three-address-code is translated into instruction objects being modeled considering the jvm specification for those ones. The generated code is added to the code attribute of the previously generated classfile's main-method, afterwards.</li>
<li>Finally, the translator returns a Collection of classfile objects.</li>
</ol>
<p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/">JVM Specification - </a><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/">http://docs.oracle.com/javase/specs/jvms/se7/html/</a>

</p>
<h3 id="module-descriptions/compiler">Compiler</h3>
<p>There are three ways to work with the compiler: via JUnit-test, via CLI and via GUI. All of these implementations base on <a href="https://github.com/swp-uebersetzerbau-ss13/javabite/blob/master/javabite-common/src/main/java/swp_compiler_ss13/javabite/compiler/AbstractJavabiteCompiler.java"><strong>swp_compiler_ss13.javabite.compiler.AbstractJavabiteCompiler</strong></a>.

</p>
<p>The <em>AbstractJavabiteCompiler</em> loads all necessary module via the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html">Java ServiceLoader API</a> and select the implementation like defined in the javabite.properties file, which gets generated if not existing on startup.

</p>
<p>The compilation process is implemented based on the requirements of the common interfaces and after each phase of the compilation process (each module providing a phase), a notification method is called which can abort the compilation process.

</p>
<h3 id="module-descriptions/ide-environment">IDE Environment</h3>
<p>The Javabite IDE is not only a wrapper for the command line interface. With the IDE files can be edited and compiled without always typing in the command line. The following list shows the main functionalities of the Javabite compiler:

</p>
<ul>
<li>opening, editing and saving files</li>
<li>compiling and running the sourcecode</li>
<li>syntax highlighting and TokenType mouseover for sourcecode</li>
<li>viewing report logs containing warning and error messages found while compiling</li>
<li>viewing compiler internal logs</li>
<li>display the sourcecode as an abstract syntax tree</li>
<li>display the sourcecode as an three address code in quadruple</li>
</ul>
<h2 id="project-structure">Project Structure</h2>
<p>The project consists of eigth projects, each responsible for another part of the compiler:

</p>
<ol>
<li>common<ul>
<li>common contains the language specification, tests to check for interface conformance of a implementation and the common interfaces</li>
<li>this a <em>git submodule</em> of the common repository</li>
</ul>
</li>
<li>javabite-common<ul>
<li>contains implementation of the project common classes</li>
</ul>
</li>
<li>javabite-lexer<ul>
<li>contains lexer for the common grammar</li>
</ul>
</li>
<li>javabite-parser<ul>
<li>contains parser for the common grammar</li>
</ul>
</li>
<li>javabite-semantic<ul>
<li>contains semantical analyzer for the common grammar</li>
</ul>
</li>
<li>javabite-code-gen<ul>
<li>contains the generation for the three address code</li>
</ul>
</li>
<li>javabite-backend<ul>
<li>conatins javabite-backend generating <em>Java ByteCode</em></li>
</ul>
</li>
<li>javabite-compiler<ul>
<li>contains the main application with user interface</li>
</ul>
</li>
</ol>
<h3 id="project-structure/setup-of-development-environment">Setup of development environment</h3>
<p>The following is needed:
+ a recent git installation

</p>
<p>Recommended is:
+ Eclipse
+ a gradle installation (you get one automatically by executing the gradlew-command)
+ Gradle Integration for Eclipse (available through Eclipse Marketplace)

</p>
<p>If another IDE integration plugin in the build.gralde is needed, please open issue.

</p>
<ol>
<li><p>Checkout the repository to a location you want. Execute:</p>
<pre><code><span class="title">git</span> submodule init
<span class="title">git</span> submodule update</code></pre>
</li>
<li>Go to the "Import..." in eclipse and select Gradle-&gt;Gradle Project.</li>
<li>Select the repository location and press "Build Model"</li>
<li>Select all projects</li>
<li>Press "finish"</li>
</ol>
<p>Eclipse will setup repository for you.

</p>
<h3 id="project-structure/runtime-test">Runtime test</h3>
<p>They can be executed with: <code>gradlew :javabite-compiler:test</code>
</p>

  </div>
</div>
</body></html>